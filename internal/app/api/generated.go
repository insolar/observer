// Copyright 2020 Insolar Network Ltd.
// All rights reserved.
// This material is licensed under the Insolar License version 1.0,
// available at https://github.com/insolar/observer/blob/master/LICENSE.md.

// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.

// +build node

package api

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
)

// ResponsesInvalidReferenceYaml defines model for responses-invalidReference-yaml.
type ResponsesInvalidReferenceYaml struct {

	// Array of error messages.
	Error []string `json:"error"`
}

// ResponsesInvalidTransactionIdYaml defines model for responses-invalidTransactionId-yaml.
type ResponsesInvalidTransactionIdYaml struct {

	// Array of error messages.
	Error []string `json:"error"`
}

// ResponsesMemberYaml defines model for responses-member-yaml.
type ResponsesMemberYaml struct {

	// Reference to the member's account object.
	AccountReference string `json:"accountReference"`

	// Account's balance in XNS coin fractions expressed as an integer. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	Balance string `json:"balance"`

	// Amount of burned XNS coin fractions expressed as an integer, optional. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	BurnedBalance *string `json:"burnedBalance,omitempty"`

	// Deposits associated with the member.
	Deposits *[]SchemaDeposit `json:"deposits,omitempty"`

	// Special address on the Ethereum network—a transfer destination for INS tokens during the migration period.
	MigrationAddress *string `json:"migrationAddress,omitempty"`

	// Reference to the `member` object.
	Reference string `json:"reference"`

	// Reference to the member's wallet object.
	WalletReference string `json:"walletReference"`
}

// ResponsesMemberBalanceYaml defines model for responses-memberBalance-yaml.
type ResponsesMemberBalanceYaml struct {

	// Member's balance in XNS coin fractions expressed as an integer. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	Balance string `json:"balance"`
}

// ResponsesPulseNumberYaml defines model for responses-pulse-number-yaml.
type ResponsesPulseNumberYaml struct {

	// Number of the latest finalized pulse.
	PulseNumber int64 `json:"pulseNumber"`
}

// ResponsesPulseRangeYaml defines model for responses-pulse-range-yaml.
type ResponsesPulseRangeYaml []int64

// SchemaAllocation defines model for schema-allocation.
type SchemaAllocation struct {
	// Embedded struct due to allOf(#/components/schemas/schemas-transactionAbstract)
	SchemasTransactionAbstract
	// Embedded fields due to inline allOf schema

	// Reference to the sending member object (migration daemon).
	FromMemberReference string `json:"fromMemberReference"`

	// Reference to the receiving deposit object.
	ToDepositReference string `json:"toDepositReference"`

	// Reference to the receiving member object.
	ToMemberReference string `json:"toMemberReference"`
	Type              string `json:"type"`
}

// SchemaBurn defines model for schema-burn.
type SchemaBurn struct {
	// Embedded struct due to allOf(#/components/schemas/schemas-transactionAbstract)
	SchemasTransactionAbstract
	// Embedded fields due to inline allOf schema

	// Reference to the sending member object.
	FromMemberReference string `json:"fromMemberReference"`

	// Reference to the receiving member object.
	ToMemberReference *string `json:"toMemberReference"`
	Type              string  `json:"type"`
}

// SchemaDeposit defines model for schema-deposit.
type SchemaDeposit struct {

	// An integer amount of XNS coin fractions in the deposit that are on hold. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	AmountOnHold string `json:"amountOnHold"`

	// An integer amount of XNS coin fractions available for transfer from the deposit. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	AvailableAmount string `json:"availableAmount"`

	// Reference to the `deposit` object.
	DepositReference string `json:"depositReference"`

	// Ethereum transaction hash associated with the deposit.
	EthTxHash string `json:"ethTxHash"`

	// Date in Unix timestamp format to start the release of the held coins.
	HoldReleaseDate int64 `json:"holdReleaseDate"`

	// Deposit sequence number.
	Index int `json:"index"`

	// Reference to the `member` object. Returned if, instead of `reference`, the request had a `migrationAddress` in path.
	MemberReference *string `json:"memberReference,omitempty"`

	// Next partial release—amount of XNS coin fractions to release at a particular Unix timestamp in the future.
	NextRelease *SchemaNextRelease `json:"nextRelease,omitempty"`

	// Date in Unix timestamp format to end the release period meaning release of all coins.
	ReleaseEndDate int64 `json:"releaseEndDate"`

	// An integer amount of released XNS coin fractions from the start of the release period. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	ReleasedAmount string `json:"releasedAmount"`

	// * `AVAILABLE`—deposit is active, you can transfer coins from it.
	// * `LOCKED`—deposit is on hold until the `releaseEndDate`.
	// * `MIGRATION`—approvals from migration daemons are being collected.
	Status string `json:"status"`

	// Deposit creation time in Unix timestamp format.
	Timestamp int64 `json:"timestamp"`
}

// SchemaMigration defines model for schema-migration.
type SchemaMigration struct {
	// Embedded struct due to allOf(#/components/schemas/schemas-transactionAbstract)
	SchemasTransactionAbstract
	// Embedded fields due to inline allOf schema

	// Reference to the sending member object (migration daemon).
	FromMemberReference string `json:"fromMemberReference"`

	// Reference to the receiving deposit object.
	ToDepositReference string `json:"toDepositReference"`

	// Reference to the receiving member object.
	ToMemberReference string `json:"toMemberReference"`
	Type              string `json:"type"`
}

// SchemaNextRelease defines model for schema-next-release.
type SchemaNextRelease struct {

	// An integer amount of XNS coin fractions to release. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	Amount string `json:"amount"`

	// Unix timestamp in the future.
	Timestamp int64 `json:"timestamp"`
}

// SchemaRelease defines model for schema-release.
type SchemaRelease struct {
	// Embedded struct due to allOf(#/components/schemas/schemas-transactionAbstract)
	SchemasTransactionAbstract
	// Embedded fields due to inline allOf schema

	// Reference to the sending deposit object.
	FromDepositReference string `json:"fromDepositReference"`

	// Reference to the receiving member object.
	ToMemberReference string `json:"toMemberReference"`
	Type              string `json:"type"`
}

// SchemaTransfer defines model for schema-transfer.
type SchemaTransfer struct {
	// Embedded struct due to allOf(#/components/schemas/schemas-transactionAbstract)
	SchemasTransactionAbstract
	// Embedded fields due to inline allOf schema

	// Reference to the sending member object.
	FromMemberReference string `json:"fromMemberReference"`

	// Reference to the receiving member object.
	ToMemberReference *string `json:"toMemberReference"`
	Type              string  `json:"type"`
}

// SchemasTransaction defines model for schemas-transaction.
type SchemasTransaction interface{}

// SchemasTransactionAbstract defines model for schemas-transactionAbstract.
type SchemasTransactionAbstract struct {

	// An integer amount of XNS coin fractions. The smallest XNS fraction is `1/10^10`. To calculate an XNS value, divide the number of fractions by `10^10`. For example: `1000000000 fractions / 10^10 = 0.1 XNS`.
	Amount string `json:"amount"`

	// Fee value in XNS coin fractions. Only finalized transactions (with `received` status) have this value.
	Fee *string `json:"fee,omitempty"`

	// Transaction index.
	Index string `json:"index"`

	// Pulse number at the transaction timestamp.
	PulseNumber int64 `json:"pulseNumber"`

	// Transaction status:
	//
	// * `registered`—transfer request is registered.
	// * `sent`—transfer of funds from the sender is finalized.
	// * `received`—transfer of funds to the receiver is finalized.
	// * `failed`—transfer of funds is finalized with an error; for example, in case of insufficient balance.
	Status string `json:"status"`

	// Unix timestamp of the initial transfer request.
	Timestamp int64 `json:"timestamp"`

	// Transaction ID.
	TxID string `json:"txID"`

	// Transaction type that all references depend on.
	Type string `json:"type"`
}

// SchemasTransactions defines model for schemas-transactions.
type SchemasTransactions []SchemasTransaction

// InvalidTransactionListParameters defines model for invalidTransactionListParameters.
type InvalidTransactionListParameters struct {

	// Array of error messages.
	Error []string `json:"error"`
}

// Transactions defines model for transactions.
type Transactions struct {
	// Embedded fields due to inline allOf schema
	// Embedded struct due to allOf(#/components/schemas/schemas-transactions)
	SchemasTransactions
}

// MemberByPublicKeyParams defines parameters for MemberByPublicKey.
type MemberByPublicKeyParams struct {

	// Public key of the target `member` object. With or without the `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----` delimiters.
	//
	// Note: Query parameters must be properly included into the URL, so `publicKey` value should comply with the HTML URL encoding.
	PublicKey string `json:"publicKey"`
}

// MemberTransactionsParams defines parameters for MemberTransactions.
type MemberTransactionsParams struct {

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the last known transaction. The list starts from the next one.
	// Each returned transaction has an `index` that can be specified as the value of this parameter.
	//
	// To get the list of most recent or old (depending on the `order` value) transactions, omit the index.
	Index *string `json:"index,omitempty"`

	// Transaction direction:
	//
	//   * `incoming`—only transactions to the `member`.
	//   * `outgoing`—only transactions from the `member`.
	//   * `all`—both of the above.
	Direction *string `json:"direction,omitempty"`

	// Chronological `order` of the transaction list starting from a given `index`:
	//
	//   * `chronological`—get transactions that chronologically follow a transaction with a given `index`.
	//   * `reverse`—get transactions that chronologically preceed a transaction with a given `index.
	Order *string `json:"order,omitempty"`

	// Transaction type:
	//
	// * `transfer`—transactions to/from the member.
	// * `migration`—only transactions to the member's deposits.
	// * `allocation`—only transactions used by Insolar for internal funding purposes.
	// * `release`—only transactions from the member's deposits to this member's account.
	// * `burn`-only transactions used by Insolar for internal burning purposes.
	Type *string `json:"type,omitempty"`

	// Transaction status:
	//
	// * `registered`—transfer request is registered.
	// * `sent`—transfer of funds from the sender is finalized.
	// * `received`—transfer of funds to the receiver is finalized.
	// * `failed`—transfer of funds is finalized with an error; for example, in case of insufficient balance.
	Status *string `json:"status,omitempty"`
}

// PulseRangeParams defines parameters for PulseRange.
type PulseRangeParams struct {

	// Unix timestamp to start the finalized pulse number range from. Must chronologically precede the `toTimestamp` parameter.
	FromTimestamp int64 `json:"fromTimestamp"`

	// Unix timestamp to end the finalized pulse number range at. Must chronologically succeed the `fromTimestamp` parameter.
	ToTimestamp int64 `json:"toTimestamp"`

	// Number of integers in the returned array.
	Limit int `json:"limit"`

	// Last known `pulseNumber`. Array starts from the next one.
	//
	// Each returned `pulseNumber` can be specified as the value of this parameter in subsequent requests.
	//
	// To get a `pulseNumber` array that starts from the nearest pulse after the `fromTimestamp` value, omit this parameter.
	PulseNumber *int64 `json:"pulseNumber,omitempty"`
}

// TransactionsSearchParams defines parameters for TransactionsSearch.
type TransactionsSearchParams struct {

	// Value of `txID`, `fromMemberReference`, `toMemberReference` or `pulseNumber` by which to search (filter) transactions.
	//
	// Note: Path parameters must be properly included into the URL, so `:` after `insolar` in references and IDs should be replaced with `%3A` to comply with the HTML URL encoding.
	Value *string `json:"value,omitempty"`

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the last known transaction. List starts from the next one.
	//
	// Each returned transaction has an `index` that can be specified as the value of this parameter.
	//
	// To get the list of most recent or old (depending on the `order` value) transactions, omit the index.
	Index *string `json:"index,omitempty"`

	// Chronological `order` of the transaction list starting from a given `index`:
	//
	//   * `chronological`—get transactions that chronologically follow a transaction with a given `index`;
	//   * `reverse`—get transactions that chronologically precede a transaction with a given `index`.
	Order *string `json:"order,omitempty"`

	// Transaction type:
	//
	// * `transfer`—transactions to/from to the member.
	// * `migration`—only transactions to the member's deposits.
	// * `allocation`—only transactions used by Insolar for internal funding purposes.
	// * `release`—only transactions from the member's deposits to this member's account.
	// * `burn`-transfers of burned coins from the member.
	Type *string `json:"type,omitempty"`

	// Transaction status:
	//
	// * `registered`—transfer request is registered.
	// * `sent`—transfer of funds from the sender is finalized.
	// * `received`—transfer of funds to the receiver is finalized.
	// * `failed`—transfer of funds is finalized with an error; for example, in case of insufficient balance.
	Status *string `json:"status,omitempty"`
}

// ClosedTransactionsParams defines parameters for ClosedTransactions.
type ClosedTransactionsParams struct {

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the last known transaction. The list starts from the next one.
	//
	// Each returned transaction has an `index` that can be specified as the value of this parameter.
	//
	// To get the list of most recent or old (depending on the `order` value) transactions, omit the index.
	Index *string `json:"index,omitempty"`

	// Chronological `order` of the transaction list starting from a given `index`:
	//
	//   * `chronological`—get transactions that chronologically follow a transaction with a given `index`.
	//   * `reverse`—get transactions that chronologically precede a transaction with a given `index`.
	Order *string `json:"order,omitempty"`
}

// TransactionsByPulseNumberRangeParams defines parameters for TransactionsByPulseNumberRange.
type TransactionsByPulseNumberRangeParams struct {

	// Reference to the `member` object.
	//
	// Note: Path parameters must be properly included into the URL, so `:` after `insolar` in references and IDs should be replaced with `%3A` to comply with the HTML URL encoding.
	MemberReference *string `json:"memberReference,omitempty"`

	// Pulse number to start the first transaction list from. This parameter must chronologically precede the `toPulseNumber`.
	FromPulseNumber int64 `json:"fromPulseNumber"`

	// Pulse number to end the last transaction list at. This parameter must chronologically succeed the `fromPulseNumber`.
	ToPulseNumber int64 `json:"toPulseNumber"`

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the last known transaction. The list starts from the next one.
	//
	// Each returned transaction has an `index` that can be specified as the value of this parameter.
	//
	// To get the list transactions with a pulse number starting from the value of `fromPulseNumber`, omit the index.
	Index *string `json:"index,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Member by public key
	// (GET /api/member/byPublicKey)
	MemberByPublicKey(ctx echo.Context, params MemberByPublicKeyParams) error
	// Member
	// (GET /api/member/{reference})
	Member(ctx echo.Context, reference string) error
	// Member balance
	// (GET /api/member/{reference}/balance)
	Balance(ctx echo.Context, reference string) error
	// Member transactions
	// (GET /api/member/{reference}/transactions)
	MemberTransactions(ctx echo.Context, reference string, params MemberTransactionsParams) error
	// Pulse number
	// (GET /api/pulse/number)
	PulseNumber(ctx echo.Context) error
	// Pulse number range
	// (GET /api/pulse/range)
	PulseRange(ctx echo.Context, params PulseRangeParams) error
	// Transaction
	// (GET /api/transaction/{txID})
	Transaction(ctx echo.Context, txID string) error
	// Transactions
	// (GET /api/transactions)
	TransactionsSearch(ctx echo.Context, params TransactionsSearchParams) error
	// Closed transactions
	// (GET /api/transactions/closed)
	ClosedTransactions(ctx echo.Context, params ClosedTransactionsParams) error
	// Transactions within a range of pulse numbers
	// (GET /api/transactions/inPulseNumberRange)
	TransactionsByPulseNumberRange(ctx echo.Context, params TransactionsByPulseNumberRangeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// MemberByPublicKey converts echo context to params.
func (w *ServerInterfaceWrapper) MemberByPublicKey(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MemberByPublicKeyParams
	// ------------- Required query parameter "publicKey" -------------

	err = runtime.BindQueryParameter("form", true, true, "publicKey", ctx.QueryParams(), &params.PublicKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter publicKey: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MemberByPublicKey(ctx, params)
	return err
}

// Member converts echo context to params.
func (w *ServerInterfaceWrapper) Member(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Member(ctx, reference)
	return err
}

// Balance converts echo context to params.
func (w *ServerInterfaceWrapper) Balance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Balance(ctx, reference)
	return err
}

// MemberTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) MemberTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params MemberTransactionsParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MemberTransactions(ctx, reference, params)
	return err
}

// PulseNumber converts echo context to params.
func (w *ServerInterfaceWrapper) PulseNumber(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PulseNumber(ctx)
	return err
}

// PulseRange converts echo context to params.
func (w *ServerInterfaceWrapper) PulseRange(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PulseRangeParams
	// ------------- Required query parameter "fromTimestamp" -------------

	err = runtime.BindQueryParameter("form", true, true, "fromTimestamp", ctx.QueryParams(), &params.FromTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fromTimestamp: %s", err))
	}

	// ------------- Required query parameter "toTimestamp" -------------

	err = runtime.BindQueryParameter("form", true, true, "toTimestamp", ctx.QueryParams(), &params.ToTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter toTimestamp: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "pulseNumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "pulseNumber", ctx.QueryParams(), &params.PulseNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pulseNumber: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PulseRange(ctx, params)
	return err
}

// Transaction converts echo context to params.
func (w *ServerInterfaceWrapper) Transaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txID" -------------
	var txID string

	err = runtime.BindStyledParameter("simple", false, "txID", ctx.Param("txID"), &txID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Transaction(ctx, txID)
	return err
}

// TransactionsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionsSearch(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionsSearchParams
	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", true, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionsSearch(ctx, params)
	return err
}

// ClosedTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) ClosedTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ClosedTransactionsParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ClosedTransactions(ctx, params)
	return err
}

// TransactionsByPulseNumberRange converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionsByPulseNumberRange(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionsByPulseNumberRangeParams
	// ------------- Optional query parameter "memberReference" -------------

	err = runtime.BindQueryParameter("form", true, false, "memberReference", ctx.QueryParams(), &params.MemberReference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberReference: %s", err))
	}

	// ------------- Required query parameter "fromPulseNumber" -------------

	err = runtime.BindQueryParameter("form", true, true, "fromPulseNumber", ctx.QueryParams(), &params.FromPulseNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fromPulseNumber: %s", err))
	}

	// ------------- Required query parameter "toPulseNumber" -------------

	err = runtime.BindQueryParameter("form", true, true, "toPulseNumber", ctx.QueryParams(), &params.ToPulseNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter toPulseNumber: %s", err))
	}

	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionsByPulseNumberRange(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/member/byPublicKey", wrapper.MemberByPublicKey)
	router.GET("/api/member/:reference", wrapper.Member)
	router.GET("/api/member/:reference/balance", wrapper.Balance)
	router.GET("/api/member/:reference/transactions", wrapper.MemberTransactions)
	router.GET("/api/pulse/number", wrapper.PulseNumber)
	router.GET("/api/pulse/range", wrapper.PulseRange)
	router.GET("/api/transaction/:txID", wrapper.Transaction)
	router.GET("/api/transactions", wrapper.TransactionsSearch)
	router.GET("/api/transactions/closed", wrapper.ClosedTransactions)
	router.GET("/api/transactions/inPulseNumberRange", wrapper.TransactionsByPulseNumberRange)

}
